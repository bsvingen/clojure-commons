<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>commons.clojure.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure-commons 0.9.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>commons</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-3 current"><a href="commons.clojure.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="commons.control-flow.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>control-flow</span></div></a></li><li class="depth-2 branch"><a href="commons.environment.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>environment</span></div></a></li><li class="depth-2 branch"><a href="commons.function-makers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function-makers</span></div></a></li><li class="depth-2 branch"><a href="commons.maps.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maps</span></div></a></li><li class="depth-2 branch"><a href="commons.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-2 branch"><a href="commons.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2"><a href="commons.sequences.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sequences</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="commons.clojure.core.html#var-.2Bfind-var"><div class="inner"><span>+find-var</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-.2Bsymbol"><div class="inner"><span>+symbol</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3C.3E"><div class="inner"><span>-!&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3E"><div class="inner"><span>-!&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3E.3E"><div class="inner"><span>-!&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.3C.3E"><div class="inner"><span>-&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.3C.3E.3E"><div class="inner"><span>-&lt;&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-any.3F"><div class="inner"><span>any?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-big-decimal.3F"><div class="inner"><span>big-decimal?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-branch-on"><div class="inner"><span>branch-on</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-cl-format"><div class="inner"><span>cl-format</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-classic-map.3F"><div class="inner"><span>classic-map?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-env"><div class="inner"><span>env</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-env-nil-ok"><div class="inner"><span>env-nil-ok</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-extended-fn.3F"><div class="inner"><span>extended-fn?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-find-first"><div class="inner"><span>find-first</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-form-hash"><div class="inner"><span>form-hash</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-fourth"><div class="inner"><span>fourth</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-guid"><div class="inner"><span>guid</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-linear-access.3F"><div class="inner"><span>linear-access?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-named.3F"><div class="inner"><span>named?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-namespace.3F"><div class="inner"><span>namespace?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-not-empty.3F"><div class="inner"><span>not-empty?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-pprint"><div class="inner"><span>pprint</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-prog1"><div class="inner"><span>prog1</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-regex.3F"><div class="inner"><span>regex?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-rename-keys"><div class="inner"><span>rename-keys</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-some-.3C.3E"><div class="inner"><span>some-&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-some-.3C.3E.3E"><div class="inner"><span>some-&lt;&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-stringlike.3F"><div class="inner"><span>stringlike?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-subset.3F"><div class="inner"><span>subset?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-third"><div class="inner"><span>third</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-throw.2B"><div class="inner"><span>throw+</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-try.2B"><div class="inner"><span>try+</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-uuid"><div class="inner"><span>uuid</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-without-nils"><div class="inner"><span>without-nils</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">commons.clojure.core</h2><div class="doc"><div class="markdown"><p>Functions I wouldn&rsquo;t mind seeing in clojure.core</p></div></div><div class="public anchor" id="var-.2Bfind-var"><h3>+find-var</h3><div class="usage"><code>(+find-var name)</code><code>(+find-var ns name)</code></div><div class="doc"><div class="markdown"><p>Return a variable identified by the arguments, or <code>nil</code>. A version of the built-in function, but with a wider domain.</p><p><em>Case 1</em>: If the single argument is a namespace-qualified symbol, the behavior is the same as <code>clojure.core/find-var</code>: the variable of that name in that namespace is returned:</p>
<pre><code>(+find-var &#39;clojure.core/even?) =&gt; #&#39;clojure.core/even?
</code></pre><p>Note that the namespace <em>must</em> exist or an exception is thrown. </p><p>Strings with a single slash are treated as symbols:</p>
<pre><code>(+find-var &quot;clojure.core/even?&quot;) =&gt; #&#39;clojure.core/even?
</code></pre><p>Namespace-qualified keywords can also be used.</p><p><em>Case 2</em>: If the single argument is not namespace-qualified, it is treated as if it were qualified with <code>*ns*</code>:</p>
<pre><code>(+find-var &#39;find-var) =&gt; #&#39;this.namespace/find-var
(+find-var &quot;symbol&quot;) =&gt; #&#39;this.namespace/symbol
</code></pre><p><em>Case 3</em>: If the single argument is a var, it is returned.</p><p><em>Case 4</em>: In the two-argument case, the <code>ns</code> argument supplies the namespace and the <code>name</code> argument the var&rsquo;s name. <code>ns</code> may be a namespace, symbol, keyword, or string (<a href="null">as-ns-symbol</a>). <code>name</code> may be a string, symbol, keyword, or var. In the first three cases, the namespace part of <code>name</code> (if any) is ignored:</p>
<pre><code>(+find-var &#39;such.wide-domains &#39;clojure.core/find-var) =&gt; #&#39;such.wide-domains/find-var
(+find-var *ns* :find-var) =&gt; #&#39;this.namespace/find-var
</code></pre><p>If the <code>name</code> argument is a var, <code>find-var</code> looks for a var with the same name in <code>ns</code>:</p>
<pre><code>(+find-var &#39;such.wide-domains #&#39;clojure.core/find-var) =&gt; #&#39;such.wide-domains/find-var
</code></pre></div></div></div><div class="public anchor" id="var-.2Bsymbol"><h3>+symbol</h3><div class="usage"><code>(+symbol name)</code><code>(+symbol ns name)</code></div><div class="doc"><div class="markdown"><p>Creates a symbol. A variant of the <code>clojure.core</code> version with a wider domain.<br/>The <code>ns</code> argument may be a namespace, symbol, keyword, or string (<a href="null">as-ns-string</a>).<br/>The <code>name</code> argument may be a symbol, string, keyword, or var (<a href="null">as-string-without-namespace</a>).</p><p>In the one-argument version, the resulting symbol has a <code>nil</code> namespace. In the two-argument version, it has the symbol version of <code>ns</code> as the namespace. Note that <code>ns</code> need not refer to an existing namespace.</p>
<pre><code>(+symbol &quot;th&quot;) =&gt; &#39;th
(+symbol &#39;clojure.core &quot;th&quot;) =&gt; &#39;clojure.core/th

(+symbol *ns* &#39;th) =&gt; &#39;this.namespace/th ; &quot;add&quot; a namespace
(+symbol *ns* &#39;clojure.core/even?) =&gt; &#39;this.namespace/even? ; &quot;localize&quot; a symbol.
</code></pre></div></div></div><div class="public anchor" id="var--.21.3C.3E"><h3>-!&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&lt;&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&lt;&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.21.3E"><h3>-!&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.21.3E.3E"><h3>-!&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&gt;&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&gt;&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.3C.3E"><h3>-&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-&lt;&gt; x)</code><code>(-&lt;&gt; x form)</code><code>(-&lt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the &lsquo;diamond wand&rsquo;: top-level insertion of x in place of single positional &lsquo;&lt;&gt;&rsquo; symbol within the threaded form if present, otherwise mostly behave as the thread-first macro. Also works with hash literals and vectors.</p></div></div></div><div class="public anchor" id="var--.3C.3E.3E"><h3>-&lt;&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-&lt;&gt;&gt; x)</code><code>(-&lt;&gt;&gt; x form)</code><code>(-&lt;&gt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the &lsquo;diamond spear&rsquo;: top-level insertion of x in place of single positional &lsquo;&lt;&gt;&rsquo; symbol within the threaded form if present, otherwise mostly behave as the thread-last macro. Also works with hash literals and vectors.</p></div></div></div><div class="public anchor" id="var-any.3F"><h3>any?</h3><div class="usage"><code>(any? predlike coll)</code></div><div class="doc"><div class="markdown"><p><code>any?</code> provides shorthand for &ldquo;containment&rdquo; queries that otherwise require different functions. Behavior depends on the type of <code>predlike</code>.</p>
<ul>
  <li><p>A function: <code>true</code> iff <code>predlike</code> returns a <em>truthy</em> value for any value in <code>coll</code>.</p>
  <pre><code> (any? even? [1 2 3]) =&gt; true           ; works best with boolean-valued functions
 (any? inc [1 2 3]) =&gt; true             ; a silly example to demo truthiness.
 (any? identity [nil false]) =&gt; false   ; also silly
</code></pre></li>
  <li><p>A collection: <code>true</code> iff <code>predlike</code> contains any element of <code>coll</code>.</p>
  <pre><code> (any? #{1 3} [5 4 1]) =&gt; true
 (any? [1 3] [5 4 1]) =&gt; true
</code></pre><p>When <code>predlike</code> is a map, it checks key/value pairs:</p>
  <pre><code> (any? {:a 1} {:a 1}) =&gt; true
 (any? {:a 1} {:a 2}) =&gt; false
 (any? {:a 2, :b 1} {:b 1, :c 3}) =&gt; true
</code></pre></li>
  <li><p>A keyword: <code>true</code> iff <code>predlike</code> is a key in <code>coll</code>, which <em>must</em> be a map.</p>
  <pre><code> (any? :a {:a 1, :b 2}) =&gt; true         ; equivalent to:
 (contains? {:a 1, :b 2} :a) =&gt; true
</code></pre></li>
</ul></div></div></div><div class="public anchor" id="var-big-decimal.3F"><h3>big-decimal?</h3><div class="usage"><code>(big-decimal? x)</code></div><div class="doc"><div class="markdown"><p>Is x a Java BigDecimal?</p></div></div></div><div class="public anchor" id="var-branch-on"><h3>branch-on</h3><h4 class="type">macro</h4><div class="usage"><code>(branch-on value-form &amp; body)</code></div><div class="doc"><div class="markdown"><pre><code>(branch-on (str &quot;one&quot; &quot;two&quot;)
   vector?   :vector
   string?   :string
   :else     :unknown)
</code></pre><p>Evaluates the <code>value-form</code> once, then checks that value against each predicate in the cond-like body. The value after the first matching predicate is returned. If there is no match and an <code>:else</code> clause is present, its value is returned, otherwise <code>nil</code>.</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/control_flow.clj#L5">view source</a></div></div><div class="public anchor" id="var-cl-format"><h3>cl-format</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(cl-format writer format-in &amp; args)</code></div><div class="doc"><div class="markdown"><p>An implementation of a Common Lisp compatible format function. cl-format formats its arguments to an output stream or string based on the format control string given. It supports sophisticated formatting of structured data.</p><p>Writer is an instance of java.io.Writer, true to output to <em>out</em> or nil to output to a string, format-in is the format control string and the remaining arguments are the data to be formatted.</p><p>The format control string is a string to be output with embedded &lsquo;format directives&rsquo; describing how to format the various arguments passed in.</p><p>If writer is nil, cl-format returns the formatted result string. Otherwise, cl-format returns nil.</p><p>For example:  (let [results [46 38 22]]  (cl-format true &ldquo;There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%&rdquo;  (count results) results))</p><p>Prints to <em>out</em>:  There are 3 results: 46, 38, 22</p><p>Detailed documentation on format control strings is available in the &ldquo;Common Lisp the Language, 2nd edition&rdquo;, Chapter 22 (available online at: <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000">http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000</a>) and in the Common Lisp HyperSpec at <a href="http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm">http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm</a></p></div></div></div><div class="public anchor" id="var-classic-map.3F"><h3>classic-map?</h3><div class="usage"><code>(classic-map? x)</code></div><div class="doc"><div class="markdown"><p><code>map?</code> will return true for Records. This returns true only for hashmaps and sorted maps.</p></div></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(difference s1)</code><code>(difference s1 s2)</code><code>(difference s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the first set without elements of the remaining sets</p></div></div></div><div class="public anchor" id="var-env"><h3>env</h3><div class="usage"><code>(env key)</code></div><div class="doc"><div class="markdown"><p>Select a keyword <code>key</code> from the environment. The result is a string. It is an error for the environment lookup to return <code>nil</code>. See <a href="commons.clojure.core.html#var-env-nil-ok">env-nil-ok</a>.</p><p>Key handling and where environment values come from is per (weavejester/environ)[https://github.com/weavejester/environ]:</p>
<pre><code> (env :home)          ; lowercased
 (env :database-url)  ; would match `DATABASE_URL`
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/environment.clj#L5">view source</a></div></div><div class="public anchor" id="var-env-nil-ok"><h3>env-nil-ok</h3><div class="usage"><code>(env-nil-ok key)</code></div><div class="doc"><div class="markdown"><p>Select a keyword <code>key&#39; from the environment, returning a string.
The result may be</code>nil`.</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/environment.clj#L20">view source</a></div></div><div class="public anchor" id="var-extended-fn.3F"><h3>extended-fn?</h3><div class="usage"><code>(extended-fn? x)</code></div><div class="doc"><div class="markdown"><p><code>fn?</code> does not consider multimethods to be functions. This does.</p></div></div></div><div class="public anchor" id="var-find-first"><h3>find-first</h3><div class="usage"><code>(find-first pred coll)</code></div><div class="doc"><div class="markdown"><p>Returns the first item of <code>coll</code> where <code>(pred item)</code> returns a truthy value, <code>nil</code> otherwise. <code>coll</code> is evaluated lazily.</p>
<pre><code> (find-first even? [1 2 3]) =&gt; 2
</code></pre><p>You can apply <code>find-first</code> to a map, even though which element matches &ldquo;first&rdquo; is undefined. Note that the item passed to <code>pred</code> will be a key-value pair:</p>
<pre><code> (find-first #(even? (second %)) {:a 2, :b 22, :c 222}) =&gt; [:c 222]
</code></pre></div></div></div><div class="public anchor" id="var-form-hash"><h3>form-hash</h3><div class="usage"><code>(form-hash form)</code></div><div class="doc"><div class="markdown"><p>Returns SHA-1 hash (encoded as a hex string) from the <code>prn</code> representation of the input. Use for collision avoidance when the highest security is not needed.</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/random.clj#L13">view source</a></div></div><div class="public anchor" id="var-fourth"><h3>fourth</h3><div class="usage"><code>(fourth coll)</code></div><div class="doc"><div class="markdown"><p>Returns the fourth element of <code>coll</code>. Returns <code>nil</code> if there are fewer than four elements.</p></div></div></div><div class="public anchor" id="var-guid"><h3>guid</h3><div class="usage"><code>(guid)</code></div><div class="doc"><div class="markdown"><p>A random almost-certainly-unique identifier</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/random.clj#L6">view source</a></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(intersection s1)</code><code>(intersection s1 s2)</code><code>(intersection s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the intersection of the input sets</p></div></div></div><div class="public anchor" id="var-linear-access.3F"><h3>linear-access?</h3><div class="usage"><code>(linear-access? x)</code></div><div class="doc"><div class="markdown"><p>Is the collection one where you can&rsquo;t do better than linear access?</p></div></div></div><div class="public anchor" id="var-named.3F"><h3>named?</h3><div class="usage"><code>(named? x)</code></div><div class="doc"><div class="markdown"><p>Will <code>name</code> work on x? Two cases: It implements the Named protocol OR it&rsquo;s a string.</p></div></div></div><div class="public anchor" id="var-namespace.3F"><h3>namespace?</h3><div class="usage"><code>(namespace? x)</code></div><div class="doc"><div class="markdown"><p>Is x a namespace?</p></div></div></div><div class="public anchor" id="var-not-empty.3F"><h3>not-empty?</h3><div class="usage"><code>(not-empty? value)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if <code>value</code> has any values, <code>false</code> otherwise. <code>value</code> <em>must</em> be a collection, a String, a native Java array, or something that implements the <code>Iterable</code> interface.</p></div></div></div><div class="public anchor" id="var-pprint"><h3>pprint</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(pprint object)</code><code>(pprint object writer)</code></div><div class="doc"><div class="markdown"><p>Pretty print object to the optional output writer. If the writer is not provided, print the object to the currently bound value of <em>out</em>.</p></div></div></div><div class="public anchor" id="var-prog1"><h3>prog1</h3><h4 class="type">macro</h4><div class="usage"><code>(prog1 retform &amp; body)</code></div><div class="doc"><div class="markdown"><p>The <code>retform</code> is evaluated, followed by the <code>body</code>. The value of the form is returned, so the point of <code>body</code> should be to have side-effects.</p>
<pre><code>(defn pop! [k]
   (prog1 (top k)
     (alter! k clojure.core/pop)))
</code></pre><p>The name is a homage to older Lisps.</p></div></div></div><div class="public anchor" id="var-regex.3F"><h3>regex?</h3><div class="usage"><code>(regex? x)</code></div><div class="doc"><div class="markdown"><p>Is x a regular expression (a Java Pattern)?</p></div></div></div><div class="public anchor" id="var-rename-keys"><h3>rename-keys</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(rename-keys map kmap)</code></div><div class="doc"><div class="markdown"><p>Returns the map with the keys in kmap renamed to the vals in kmap</p></div></div></div><div class="public anchor" id="var-some-.3C.3E"><h3>some-&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(some-&lt;&gt; x form)</code><code>(some-&lt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the diamond wand version of some-&gt;</p></div></div></div><div class="public anchor" id="var-some-.3C.3E.3E"><h3>some-&lt;&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(some-&lt;&gt;&gt; x form)</code><code>(some-&lt;&gt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the diamond wand version of some-&gt;&gt;</p></div></div></div><div class="public anchor" id="var-stringlike.3F"><h3>stringlike?</h3><div class="usage"><code>(stringlike? x)</code></div><div class="doc"><div class="markdown"><p>Is x a string or a regex?</p></div></div></div><div class="public anchor" id="var-subset.3F"><h3>subset?</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(subset? set1 set2)</code></div><div class="doc"><div class="markdown"><p>Is set1 a subset of set2?</p></div></div></div><div class="public anchor" id="var-third"><h3>third</h3><div class="usage"><code>(third coll)</code></div><div class="doc"><div class="markdown"><p>Returns the third element of <code>coll</code>. Returns <code>nil</code> if there are fewer than three elements.</p></div></div></div><div class="public anchor" id="var-throw.2B"><h3>throw+</h3><h4 class="type">macro</h4><div class="usage"><code>(throw+)</code><code>(throw+ object cause? message-or-fmt? &amp; fmt-args)</code></div><div class="doc"><div class="markdown"><p>Like the throw special form, but can throw any object by wrapping non-Throwable objects in a Throwable wrapper.</p><p>throw+ has the same syntax and behavior as throw for Throwable objects. The message, cause, and stack trace are those carried by the Throwable.</p><p>For non-Throwable objects, the message and cause have default values which can be overridden by optional arguments:</p><p>(throw+ object cause? message-or-fmt? &amp; fmt-args)</p>
<ul>
  <li><p>object: required, the object to throw</p></li>
  <li><p>cause: optional, a Throwable, the default is:</p>
  <ul>
    <li>within a try+ catch clause, the the outermost wrapper of  the caught object being processed,</li>
  </ul>
  <ul>
    <li>elsewhere, nil.</li>
  </ul></li>
  <li><p>message: optional, specified either as a string or a format string and args for clojure.core/format:</p>
  <ul>
    <li>% symbols anywhere within args name the thrown object</li>
  </ul>
  <ul>
    <li>the default is: &ldquo;throw+: %s&rdquo; (pr-str %)</li>
  </ul></li>
</ul><p>The stack trace is that of the current thread at the time of the throw+ call, starting at the function that encloses it;</p><p>Within a try+ catch clause, a throw+ call with no arguments rethrows the caught object within its original (possibly nested) wrappers.</p><p>See also try+, get-throw-context</p></div></div></div><div class="public anchor" id="var-try.2B"><h3>try+</h3><h4 class="type">macro</h4><div class="usage"><code>(try+ &amp; body)</code></div><div class="doc"><div class="markdown"><p>Like the try special form, but with enhanced catch clauses and an optional else clause:</p>
<ul>
  <li><p>catch non-Throwable objects thrown by throw+ or data made throwable by ex-info as well as Throwable objects thrown by throw or throw+;</p></li>
  <li><p>specify objects to catch by class name, key-values, predicate, or arbitrary selector form;</p></li>
  <li><p>destructure the caught object;</p></li>
  <li><p>an optional else clause may appear after all catch clauses and before any finally clause. Its contents will be executed (for side effects) immediately after the code in the try+ body completes only if nothing was thrown.</p></li>
</ul><p>A selector form is a form containing one or more instances of % to be replaced by the thrown object. If it evaluates to truthy, the object is caught.</p><p>The class name, key-values, and predicate selectors are  shorthand for these selector forms:</p>
<pre><code>&lt;class name&gt;          =&gt; (instance? &lt;class name&gt; %)
[&lt;key&gt; &lt;val&gt; &amp; &lt;kvs&gt;] =&gt; (and (= (get % &lt;key&gt;) &lt;val&gt;) ...)
&lt;predicate&gt;           =&gt; (&lt;predicate&gt; %)
</code></pre><p>The binding form in a try+ catch clause is not required to be a simple symbol. It is subject to destructuring which allows easy access to the contents of a thrown collection.</p><p>The local &amp;throw-context is available within try+ catch clauses, bound to the throw context for the caught object.</p><p>See also: throw+, get-throw-context</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(union)</code><code>(union s1)</code><code>(union s1 s2)</code><code>(union s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the union of the input sets</p></div></div></div><div class="public anchor" id="var-uuid"><h3>uuid</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Synonym for <code>guid</code></p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/random.clj#L11">view source</a></div></div><div class="public anchor" id="var-without-nils"><h3>without-nils</h3><div class="usage"><code>(without-nils coll)</code></div><div class="doc"><div class="markdown"><p>A lazy sequence of non-nil values of <code>coll</code>.</p></div></div></div></div></body></html>
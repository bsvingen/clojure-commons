<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>commons.clojure.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure-commons 0.6.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>commons</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-3 branch"><a href="commons.clojure.backwards-compatibility.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>backwards-compatibility</span></div></a></li><li class="depth-3 branch current"><a href="commons.clojure.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3"><a href="commons.clojure.one-dot-five.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>one-dot-five</span></div></a></li><li class="depth-2 branch"><a href="commons.control-flow.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>control-flow</span></div></a></li><li class="depth-2 branch"><a href="commons.environment.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>environment</span></div></a></li><li class="depth-2 branch"><a href="commons.maps.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maps</span></div></a></li><li class="depth-2 branch"><a href="commons.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-2 branch"><a href="commons.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2"><a href="commons.sequences.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sequences</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3C.3E"><div class="inner"><span>-!&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3E"><div class="inner"><span>-!&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.21.3E.3E"><div class="inner"><span>-!&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.3C.3E"><div class="inner"><span>-&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var--.3C.3E.3E"><div class="inner"><span>-&lt;&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-any.3F"><div class="inner"><span>any?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-big-decimal.3F"><div class="inner"><span>big-decimal?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-branch-on"><div class="inner"><span>branch-on</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-cl-format"><div class="inner"><span>cl-format</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-classic-map.3F"><div class="inner"><span>classic-map?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-defn-once"><div class="inner"><span>defn-once</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-defn-once-in-core"><div class="inner"><span>defn-once-in-core</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-env"><div class="inner"><span>env</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-env-nil-ok"><div class="inner"><span>env-nil-ok</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-extended-fn.3F"><div class="inner"><span>extended-fn?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-find-first"><div class="inner"><span>find-first</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-find-ns"><div class="inner"><span>find-ns</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-find-var"><div class="inner"><span>find-var</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-fourth"><div class="inner"><span>fourth</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-from-concatenation"><div class="inner"><span>from-concatenation</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-guid"><div class="inner"><span>guid</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-has-root-value.3F"><div class="inner"><span>has-root-value?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-linear-access.3F"><div class="inner"><span>linear-access?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-move-once-to-core"><div class="inner"><span>move-once-to-core</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-name-as-string"><div class="inner"><span>name-as-string</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-name-as-symbol"><div class="inner"><span>name-as-symbol</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-named.3F"><div class="inner"><span>named?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-namespace.3F"><div class="inner"><span>namespace?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-not-empty.3F"><div class="inner"><span>not-empty?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-ns-name"><div class="inner"><span>ns-name</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-ns-resolve"><div class="inner"><span>ns-resolve</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-pprint"><div class="inner"><span>pprint</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-regex.3F"><div class="inner"><span>regex?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-root-value"><div class="inner"><span>root-value</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-Rootable"><div class="inner"><span>Rootable</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-some-.3C.3E"><div class="inner"><span>some-&lt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-some-.3C.3E.3E"><div class="inner"><span>some-&lt;&gt;&gt;</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-stringlike.3F"><div class="inner"><span>stringlike?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-subset.3F"><div class="inner"><span>subset?</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-symbol"><div class="inner"><span>symbol</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-third"><div class="inner"><span>third</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-throw.2B"><div class="inner"><span>throw+</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-try.2B"><div class="inner"><span>try+</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-uuid"><div class="inner"><span>uuid</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-when.3C.3D1-5"><div class="inner"><span>when&lt;=1-5</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-when.3D1-4"><div class="inner"><span>when=1-4</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-when.3E.3D1-5"><div class="inner"><span>when&gt;=1-5</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-when.3E.3D1-6"><div class="inner"><span>when&gt;=1-6</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-without-namespace"><div class="inner"><span>without-namespace</span></div></a></li><li class="depth-1"><a href="commons.clojure.core.html#var-without-nils"><div class="inner"><span>without-nils</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">commons.clojure.core</h2><div class="doc"><div class="markdown"><p>Functions I wouldn&rsquo;t mind seeing in clojure.core</p></div></div><div class="public anchor" id="var--.21.3C.3E"><h3>-!&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&lt;&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&lt;&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.21.3E"><h3>-!&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.21.3E.3E"><h3>-!&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-!&gt;&gt; form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>non-updating -&gt;&gt; for unobtrusive side-effects</p></div></div></div><div class="public anchor" id="var--.3C.3E"><h3>-&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-&lt;&gt; x)</code><code>(-&lt;&gt; x form)</code><code>(-&lt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the &lsquo;diamond wand&rsquo;: top-level insertion of x in place of single positional &lsquo;&lt;&gt;&rsquo; symbol within the threaded form if present, otherwise mostly behave as the thread-first macro. Also works with hash literals and vectors.</p></div></div></div><div class="public anchor" id="var--.3C.3E.3E"><h3>-&lt;&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(-&lt;&gt;&gt; x)</code><code>(-&lt;&gt;&gt; x form)</code><code>(-&lt;&gt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the &lsquo;diamond spear&rsquo;: top-level insertion of x in place of single positional &lsquo;&lt;&gt;&rsquo; symbol within the threaded form if present, otherwise mostly behave as the thread-last macro. Also works with hash literals and vectors.</p></div></div></div><div class="public anchor" id="var-any.3F"><h3>any?</h3><div class="usage"><code>(any? predlike coll)</code></div><div class="doc"><div class="markdown"><p><code>any?</code> provides shorthand for &ldquo;containment&rdquo; queries that otherwise require different functions. Behavior depends on the type of <code>predlike</code>.</p>
<ul>
  <li><p>A function: <code>true</code> iff <code>predlike</code> returns a <em>truthy</em> value for any value in <code>coll</code>.</p>
  <pre><code> (any? even? [1 2 3]) =&gt; true           ; works best with boolean-valued functions
 (any? inc [1 2 3]) =&gt; true             ; a silly example to demo truthiness.
 (any? identity [nil false]) =&gt; false   ; also silly
</code></pre></li>
  <li><p>A collection: <code>true</code> iff <code>predlike</code> contains any element of <code>coll</code>.</p>
  <pre><code> (any? #{1 3} [5 4 1]) =&gt; true
 (any? [1 3] [5 4 1]) =&gt; true
</code></pre><p>When <code>predlike</code> is a map, it checks key/value pairs:</p>
  <pre><code> (any? {:a 1} {:a 1}) =&gt; true
 (any? {:a 1} {:a 2}) =&gt; false
 (any? {:a 2, :b 1} {:b 1, :c 3}) =&gt; true
</code></pre></li>
  <li><p>A keyword: <code>true</code> iff <code>predlike</code> is a key in <code>coll</code>, which <em>must</em> be a map.</p>
  <pre><code> (any? :a {:a 1, :b 2}) =&gt; true         ; equivalent to:
 (contains? {:a 1, :b 2} :a) =&gt; true
</code></pre></li>
</ul></div></div></div><div class="public anchor" id="var-big-decimal.3F"><h3>big-decimal?</h3><div class="usage"><code>(big-decimal? x)</code></div><div class="doc"><div class="markdown"><p>Is x a Java BigDecimal?</p></div></div></div><div class="public anchor" id="var-branch-on"><h3>branch-on</h3><h4 class="type">macro</h4><div class="usage"><code>(branch-on value-form &amp; body)</code></div><div class="doc"><div class="markdown"><pre><code>(branch-on (str &quot;one&quot; &quot;two&quot;)
   vector?   :vector
   string?   :string
   :else     :unknown)
</code></pre><p>Evaluates the <code>value-form</code> once, then checks that value against each predicate in the cond-like body. The value after the first matching predicate is returned. If there is no match and an <code>:else</code> clause is present, its value is returned, otherwise <code>nil</code>.</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/control_flow.clj#L7">view source</a></div></div><div class="public anchor" id="var-cl-format"><h3>cl-format</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(cl-format writer format-in &amp; args)</code></div><div class="doc"><div class="markdown"><p>An implementation of a Common Lisp compatible format function. cl-format formats its arguments to an output stream or string based on the format control string given. It supports sophisticated formatting of structured data.</p><p>Writer is an instance of java.io.Writer, true to output to <em>out</em> or nil to output to a string, format-in is the format control string and the remaining arguments are the data to be formatted.</p><p>The format control string is a string to be output with embedded &lsquo;format directives&rsquo; describing how to format the various arguments passed in.</p><p>If writer is nil, cl-format returns the formatted result string. Otherwise, cl-format returns nil.</p><p>For example:  (let [results [46 38 22]]  (cl-format true &ldquo;There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%&rdquo;  (count results) results))</p><p>Prints to <em>out</em>:  There are 3 results: 46, 38, 22</p><p>Detailed documentation on format control strings is available in the &ldquo;Common Lisp the Language, 2nd edition&rdquo;, Chapter 22 (available online at: <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000">http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000</a>) and in the Common Lisp HyperSpec at <a href="http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm">http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm</a></p></div></div></div><div class="public anchor" id="var-classic-map.3F"><h3>classic-map?</h3><div class="usage"><code>(classic-map? x)</code></div><div class="doc"><div class="markdown"><p><code>map?</code> will return true for Records. This returns true only for hashmaps and sorted maps.</p></div></div></div><div class="public anchor" id="var-defn-once"><h3>defn-once</h3><h4 class="type">macro</h4><div class="usage"><code>(defn-once sym &amp; rest)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/clojure/backwards_compatibility.clj#L7">view source</a></div></div><div class="public anchor" id="var-defn-once-in-core"><h3>defn-once-in-core</h3><h4 class="type">macro</h4><div class="usage"><code>(defn-once-in-core sym &amp; rest)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/clojure/backwards_compatibility.clj#L11">view source</a></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(difference s1)</code><code>(difference s1 s2)</code><code>(difference s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the first set without elements of the remaining sets</p></div></div></div><div class="public anchor" id="var-env"><h3>env</h3><div class="usage"><code>(env key)</code></div><div class="doc"><div class="markdown"><p>Select a keyword <code>key</code> from the environment. The result is a string. It is an error for the environment lookup to return <code>nil</code>. See <a href="commons.clojure.core.html#var-env-nil-ok">env-nil-ok</a>.</p><p>Key handling and where environment values come from is per (weavejester/environ)[https://github.com/weavejester/environ]:</p>
<pre><code> (env :home)          ; lowercased
 (env :database-url)  ; would match `DATABASE_URL`
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/environment.clj#L5">view source</a></div></div><div class="public anchor" id="var-env-nil-ok"><h3>env-nil-ok</h3><div class="usage"><code>(env-nil-ok key)</code></div><div class="doc"><div class="markdown"><p>Select a keyword <code>key&#39; from the environment, returning a string.
The result may be</code>nil`.</p></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/environment.clj#L20">view source</a></div></div><div class="public anchor" id="var-extended-fn.3F"><h3>extended-fn?</h3><div class="usage"><code>(extended-fn? x)</code></div><div class="doc"><div class="markdown"><p><code>fn?</code> does not consider multimethods to be functions. This does.</p></div></div></div><div class="public anchor" id="var-find-first"><h3>find-first</h3><div class="usage"><code>(find-first pred coll)</code></div><div class="doc"><div class="markdown"><p>Returns the first item of <code>coll</code> where <code>(pred item)</code> returns a truthy value, <code>nil</code> otherwise. <code>coll</code> is evaluated lazily.</p>
<pre><code> (find-first even? [1 2 3]) =&gt; 2
</code></pre><p>You can apply <code>find-first</code> to a map, even though which element matches &ldquo;first&rdquo; is undefined. Note that the item passed to <code>pred</code> will be a key-value pair:</p>
<pre><code> (find-first #(even? (second %)) {:a 2, :b 22, :c 222}) =&gt; [:c 222]
</code></pre></div></div></div><div class="public anchor" id="var-find-ns"><h3>find-ns</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(find-ns sym)</code></div><div class="doc"><div class="markdown"><p><code>sym</code> <em>must</em> be a symbol. If it names an existing namespace, that namespace is returned. Otherwise, <code>nil</code> is returned. <a href="https://clojuredocs.org/clojure.core/find-ns">Other examples</a></p>
<pre><code>(find-ns &#39;clojure.core) =&gt; #&lt;Namespace clojure.core&gt;
</code></pre></div></div></div><div class="public anchor" id="var-find-var"><h3>find-var</h3><div class="usage"><code>(find-var name)</code><code>(find-var ns name)</code></div><div class="doc"><div class="markdown"><p>Return a variable identified by the arguments, or <code>nil</code>.</p><p><em>Case 1</em>: If the single argument is a namespace-qualified symbol, the behavior is the same as <code>clojure.core/find-var</code>: the variable of that name in that namespace is returned:</p>
<pre><code>(find-var &#39;clojure.core/even?) =&gt; #&#39;clojure.core/even?
</code></pre><p>Note that the namespace <em>must</em> exist or an exception is thrown. </p><p>Strings with a single slash are treated as symbols:</p>
<pre><code>(find-var &quot;clojure.core/even?&quot;) =&gt; #&#39;clojure.core/even?
</code></pre><p>Namespace-qualified keywords can also be used.</p><p><em>Case 2</em>: If the single argument is not namespace-qualified, it is treated as if it were qualified with <code>*ns*</code>:</p>
<pre><code>(find-var &#39;find-var) =&gt; #&#39;this.namespace/find-var
(find-var &quot;symbol&quot;) =&gt; #&#39;this.namespace/symbol
</code></pre><p><em>Case 3</em>: If the single argument is a var, it is returned.</p><p><em>Case 4</em>: In the two-argument case, the <code>ns</code> argument supplies the namespace and the <code>name</code> argument the var&rsquo;s name. <code>ns</code> may be a namespace, symbol, keyword, or string (<a href="null">as-ns-symbol</a>). <code>name</code> may be a string, symbol, keyword, or var. In the first three cases, the namespace part of <code>name</code> (if any) is ignored:</p>
<pre><code>(find-var &#39;such.wide-domains &#39;clojure.core/find-var) =&gt; #&#39;such.wide-domains/find-var
(find-var *ns* :find-var) =&gt; #&#39;this.namespace/find-var
</code></pre><p>If the <code>name</code> argument is a var, <code>find-var</code> looks for a var with the same name in <code>ns</code>:</p>
<pre><code>(find-var &#39;such.wide-domains #&#39;clojure.core/find-var) =&gt; #&#39;such.wide-domains/find-var
</code></pre></div></div></div><div class="public anchor" id="var-fourth"><h3>fourth</h3><div class="usage"><code>(fourth coll)</code></div><div class="doc"><div class="markdown"><p>Returns the fourth element of <code>coll</code>. Returns <code>nil</code> if there are fewer than four elements.</p></div></div></div><div class="public anchor" id="var-from-concatenation"><h3>from-concatenation</h3><div class="usage"><code>(from-concatenation nameables join-nameable)</code><code>(from-concatenation nameables)</code></div><div class="doc"><div class="markdown"><p>Construct a symbol from the concatenation of the string versions of the <code>nameables</code>, which may be symbols, strings, keywords, or vars. If given, the <code>join-nameable</code> is interposed between the segments.</p>
<pre><code> (symbol/from-concatenation [&#39;a &quot;b&quot; :c #&#39;d]) =&gt; &#39;abcd
 (symbol/from-concatenation [&quot;a&quot; &quot;b&quot;] &#39;-) =&gt; &#39;a-b)
</code></pre><p>Note that the namespace qualifiers for symbols and strings are not included:</p>
<pre><code> (symbol/from-concatenation [:namespace/un #&#39;clojure.core/even?]) =&gt; &#39;uneven?
</code></pre></div></div></div><div class="public anchor" id="var-guid"><h3>guid</h3><div class="usage"><code>(guid)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/random.clj#L3">view source</a></div></div><div class="public anchor" id="var-has-root-value.3F"><h3>has-root-value?</h3><div class="usage"><code>(has-root-value? this)</code></div><div class="doc"><div class="markdown"><p>Does this var have a root value?</p></div></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(intersection s1)</code><code>(intersection s1 s2)</code><code>(intersection s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the intersection of the input sets</p></div></div></div><div class="public anchor" id="var-linear-access.3F"><h3>linear-access?</h3><div class="usage"><code>(linear-access? x)</code></div><div class="doc"><div class="markdown"><p>Is the collection one where you can&rsquo;t do better than linear access?</p></div></div></div><div class="public anchor" id="var-move-once-to-core"><h3>move-once-to-core</h3><h4 class="type">macro</h4><div class="usage"><code>(move-once-to-core source-namespace syms)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/clojure/backwards_compatibility.clj#L15">view source</a></div></div><div class="public anchor" id="var-name-as-string"><h3>name-as-string</h3><div class="usage"><code>(name-as-string var)</code></div><div class="doc"><div class="markdown"><p>Unlike symbols and keywords, the &ldquo;name&rdquo; of a var is a symbol. This function returns the string name of that symbol. See also <a href="commons.clojure.core.html#var-name-as-symbol">name-as-symbol</a>.</p>
<pre><code> (var/name-as-string #&#39;clojure.core/even?) =&gt; &quot;even?&quot;)
</code></pre></div></div></div><div class="public anchor" id="var-name-as-symbol"><h3>name-as-symbol</h3><div class="usage"><code>(name-as-symbol var)</code></div><div class="doc"><div class="markdown"><p>Unlike symbols and keywords, the &ldquo;name&rdquo; of a var is a symbol. This function returns that symbol. See also <a href="commons.clojure.core.html#var-name-as-string">name-as-string</a>.</p>
<pre><code> (var/name-as-symbol #&#39;clojure.core/even?) =&gt; &#39;even?)
</code></pre><p>Note that the symbol does not have a namespace.</p></div></div></div><div class="public anchor" id="var-named.3F"><h3>named?</h3><div class="usage"><code>(named? x)</code></div><div class="doc"><div class="markdown"><p>Will <code>name</code> work on x? Two cases: It implements the Named protocol OR it&rsquo;s a string.</p></div></div></div><div class="public anchor" id="var-namespace.3F"><h3>namespace?</h3><div class="usage"><code>(namespace? x)</code></div><div class="doc"><div class="markdown"><p>Is x a namespace?</p></div></div></div><div class="public anchor" id="var-not-empty.3F"><h3>not-empty?</h3><div class="usage"><code>(not-empty? value)</code></div><div class="doc"><div class="markdown"><p>Returns <code>true</code> if <code>value</code> has any values, <code>false</code> otherwise. <code>value</code> <em>must</em> be a collection, a String, a native Java array, or something that implements the <code>Iterable</code> interface.</p></div></div></div><div class="public anchor" id="var-ns-name"><h3>ns-name</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-name ns)</code></div><div class="doc"><div class="markdown"><p><code>ns</code> <em>must</em> be either a namespace or a symbol naming a namespace. If the namespace exists, its symbol-name is returned. If not, an exception is thrown. Note: the more common <code>name</code> function cannot be applied to namespaces. <a href="https://clojuredocs.org/clojure.core/ns-name">Other examples</a></p>
<pre><code>(ns-name *ns*) =&gt; &#39;such.better-doc
</code></pre></div></div></div><div class="public anchor" id="var-ns-resolve"><h3>ns-resolve</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(ns-resolve ns sym)</code><code>(ns-resolve ns env sym)</code></div><div class="doc"><div class="markdown"><p><code>ns-resolve</code> goes from a symbol to the var or class it represents. <a href="https://clojuredocs.org/clojure.core/ns-resolve">Other examples</a></p><p>The first (<code>ns</code>) argument <em>must</em> be either a namespace or a symbol naming a namespace (e.g., <code>&#39;clojure.core</code>). The final argument <code>sym</code> <em>must</em> be a symbol. There are four cases for that final argument:</p>
<ol>
  <li><p><code>sym</code> is not namespace qualified (e.g., <code>&#39;even?</code>), and you hope it corresponds  to a var in <code>ns</code>. If there is a var that (1) is &ldquo;available&rdquo; in <code>ns</code> and  (2) has the same name as <code>sym</code>, it is returned. Otherwise, <code>nil</code> is returned.  &ldquo;Available&rdquo; means the var has either been <code>intern</code>ed in the namespace or <code>refer</code>ed  into it.</p>
  <pre><code>(ns-resolve *ns* &#39;a-var) =&gt; #&#39;this.namespace/a-var
(ns-resolve *ns* &#39;even?) =&gt; #&#39;clojure.core/even?
(ns-resolve &#39;clojure.core &#39;even?) =&gt; #&#39;clojure.core/even?
</code></pre></li>
  <li><p><code>sym</code> is a namespace-qualified symbol (e.g., <code>&#39;clojure.core/even?</code>) that you hope corresponds to a var. The behavior is the same as (1), except that <code>ns</code> is not used. The symbol&rsquo;s namespace is used instead. </p>
  <pre><code>(ns-resolve *ns* &#39;clojure.core/even?) =&gt; #&#39;clojure.core/even?
</code></pre><p>Note: Even though the <code>ns</code> argument is not used in the lookup, it must still either be a namespace or a symbol that names an <em>existing</em> namespace. If not, an exception will be thrown.</p><p>Because <code>ns</code> is unused, <code>resolve</code> is better for this case.</p></li>
  <li><p><code>sym</code> is a fully qualified class name (e.g., <code>&#39;java.lang.Object</code>). If such a class exists, it is returned. Otherwise, a <code>ClassNotFoundException</code> is thrown. The <code>ns</code> argument is ignored, except that it must be a namespace or a symbol naming one.</p>
  <pre><code>(ns-resolve *ns* &#39;java.lang.Object) =&gt; java.lang.Object
</code></pre><p>Because <code>ns</code> is unused, <code>resolve</code> is better for this case. </p></li>
  <li><p><code>sym</code> is a symbol you hope names a class <code>import</code>ed into <code>ns</code>. If there is a class with that (unqualified) name in <code>ns</code>, it is returned.</p>
  <pre><code>(ns-resolve &#39;clojure.core &#39;Object) =&gt; java.lang.Object
(import &#39;java.util.AbstractCollection)
(ns-resolve *ns* &#39;AbstractCollection) =&gt; java.util.AbstractCollection
</code></pre><p>If the class hasn&rsquo;t been imported, the function returns <code>nil</code> (rather than throwing an exception, as in the fully-qualified case).</p>
  <pre><code>(ns-resolve &#39;clojure.core &#39;AbstractMethodHandlerFactoryFactory) =&gt; nil
(ns-resolve &#39;clojure.core &#39;java.lang.AbstractMethodHandlerFactoryFactory) =&gt; (throws)
</code></pre></li>
</ol><p>In the three-argument case, the second <code>env</code> argument is a map whose keys <em>must</em> be symbols. If any of the keys are <code>=</code> to the final argument, <code>nil</code> is returned (instead of a match, if any).</p>
<pre><code>(ns-resolve *ns* &#39;even?) =&gt; #&#39;clojure.core/even?
(ns-resolve *ns* &#39;{even? &quot;irrelevant&quot;} &#39;even?) =&gt; nil
(ns-resolve *ns* &#39;Object) =&gt; java.lang.Object
(ns-resolve *ns* &#39;{Object &quot;irrelevant&quot;} &#39;Object) =&gt; nil
</code></pre><p><a href="https://clojuredocs.org/clojure.core/ns-resolve">Other examples</a></p></div></div></div><div class="public anchor" id="var-pprint"><h3>pprint</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(pprint object)</code><code>(pprint object writer)</code></div><div class="doc"><div class="markdown"><p>Pretty print object to the optional output writer. If the writer is not provided, print the object to the currently bound value of <em>out</em>.</p></div></div></div><div class="public anchor" id="var-regex.3F"><h3>regex?</h3><div class="usage"><code>(regex? x)</code></div><div class="doc"><div class="markdown"><p>Is x a regular expression (a Java Pattern)?</p></div></div></div><div class="public anchor" id="var-root-value"><h3>root-value</h3><div class="usage"><code>(root-value this)</code></div><div class="doc"><div class="markdown"><p>What is the value of the var, ignoring any bindings in effect?</p></div></div></div><div class="public anchor" id="var-Rootable"><h3>Rootable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>A protocol to look at &ldquo;root&rdquo; values of Vars. The root value is the value before any <code>binding</code> - it&rsquo;s the value altered by <code>alter-var-root</code>.</p></div></div></div><div class="public anchor" id="var-some-.3C.3E"><h3>some-&lt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(some-&lt;&gt; x form)</code><code>(some-&lt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the diamond wand version of some-&gt;</p></div></div></div><div class="public anchor" id="var-some-.3C.3E.3E"><h3>some-&lt;&gt;&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(some-&lt;&gt;&gt; x form)</code><code>(some-&lt;&gt;&gt; x form &amp; forms)</code></div><div class="doc"><div class="markdown"><p>the diamond wand version of some-&gt;&gt;</p></div></div></div><div class="public anchor" id="var-stringlike.3F"><h3>stringlike?</h3><div class="usage"><code>(stringlike? x)</code></div><div class="doc"><div class="markdown"><p>Is x a string or a regex?</p></div></div></div><div class="public anchor" id="var-subset.3F"><h3>subset?</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(subset? set1 set2)</code></div><div class="doc"><div class="markdown"><p>Is set1 a subset of set2?</p></div></div></div><div class="public anchor" id="var-symbol"><h3>symbol</h3><div class="usage"><code>(symbol name)</code><code>(symbol ns name)</code></div><div class="doc"><div class="markdown"><p>Creates a symbol.<br/>The <code>ns</code> argument may be a namespace, symbol, keyword, or string (<a href="null">as-ns-string</a>).<br/>The <code>name</code> argument may be a symbol, string, keyword, or var (<a href="null">as-string-without-namespace</a>).</p><p>In the one-argument version, the resulting symbol has a <code>nil</code> namespace. In the two-argument version, it has the symbol version of <code>ns</code> as the namespace. Note that <code>ns</code> need not refer to an existing namespace.</p>
<pre><code>(symbol &quot;th&quot;) =&gt; &#39;th
(symbol &#39;clojure.core &quot;th&quot;) =&gt; &#39;clojure.core/th

(symbol *ns* &#39;th) =&gt; &#39;this.namespace/th ; &quot;add&quot; a namespace
(symbol *ns* &#39;clojure.core/even?) =&gt; &#39;this.namespace/even? ; &quot;localize&quot; a symbol.
</code></pre></div></div></div><div class="public anchor" id="var-third"><h3>third</h3><div class="usage"><code>(third coll)</code></div><div class="doc"><div class="markdown"><p>Returns the third element of <code>coll</code>. Returns <code>nil</code> if there are fewer than three elements.</p></div></div></div><div class="public anchor" id="var-throw.2B"><h3>throw+</h3><h4 class="type">macro</h4><div class="usage"><code>(throw+)</code><code>(throw+ object cause? message-or-fmt? &amp; fmt-args)</code></div><div class="doc"><div class="markdown"><p>Like the throw special form, but can throw any object by wrapping non-Throwable objects in a Throwable wrapper.</p><p>throw+ has the same syntax and behavior as throw for Throwable objects. The message, cause, and stack trace are those carried by the Throwable.</p><p>For non-Throwable objects, the message and cause have default values which can be overridden by optional arguments:</p><p>(throw+ object cause? message-or-fmt? &amp; fmt-args)</p>
<ul>
  <li><p>object: required, the object to throw</p></li>
  <li><p>cause: optional, a Throwable, the default is:</p>
  <ul>
    <li>within a try+ catch clause, the the outermost wrapper of  the caught object being processed,</li>
  </ul>
  <ul>
    <li>elsewhere, nil.</li>
  </ul></li>
  <li><p>message: optional, specified either as a string or a format string and args for clojure.core/format:</p>
  <ul>
    <li>% symbols anywhere within args name the thrown object</li>
  </ul>
  <ul>
    <li>the default is: &ldquo;throw+: %s&rdquo; (pr-str %)</li>
  </ul></li>
</ul><p>The stack trace is that of the current thread at the time of the throw+ call, starting at the function that encloses it;</p><p>Within a try+ catch clause, a throw+ call with no arguments rethrows the caught object within its original (possibly nested) wrappers.</p><p>See also try+, get-throw-context</p></div></div></div><div class="public anchor" id="var-try.2B"><h3>try+</h3><h4 class="type">macro</h4><div class="usage"><code>(try+ &amp; body)</code></div><div class="doc"><div class="markdown"><p>Like the try special form, but with enhanced catch clauses and an optional else clause:</p>
<ul>
  <li><p>catch non-Throwable objects thrown by throw+ or data made throwable by ex-info as well as Throwable objects thrown by throw or throw+;</p></li>
  <li><p>specify objects to catch by class name, key-values, predicate, or arbitrary selector form;</p></li>
  <li><p>destructure the caught object;</p></li>
  <li><p>an optional else clause may appear after all catch clauses and before any finally clause. Its contents will be executed (for side effects) immediately after the code in the try+ body completes only if nothing was thrown.</p></li>
</ul><p>A selector form is a form containing one or more instances of % to be replaced by the thrown object. If it evaluates to truthy, the object is caught.</p><p>The class name, key-values, and predicate selectors are  shorthand for these selector forms:</p>
<pre><code>&lt;class name&gt;          =&gt; (instance? &lt;class name&gt; %)
[&lt;key&gt; &lt;val&gt; &amp; &lt;kvs&gt;] =&gt; (and (= (get % &lt;key&gt;) &lt;val&gt;) ...)
&lt;predicate&gt;           =&gt; (&lt;predicate&gt; %)
</code></pre><p>The binding form in a try+ catch clause is not required to be a simple symbol. It is subject to destructuring which allows easy access to the contents of a thrown collection.</p><p>The local &amp;throw-context is available within try+ catch clauses, bound to the throw context for the caught object.</p><p>See also: throw+, get-throw-context</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(union)</code><code>(union s1)</code><code>(union s1 s2)</code><code>(union s1 s2 &amp; sets)</code></div><div class="doc"><div class="markdown"><p>Return a set that is the union of the input sets</p></div></div></div><div class="public anchor" id="var-uuid"><h3>uuid</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/marick/clojure-commons/blob/master/src/commons/random.clj#L4">view source</a></div></div><div class="public anchor" id="var-when.3C.3D1-5"><h3>when&lt;=1-5</h3><h4 class="type">macro</h4><div class="usage"><code>(when&lt;=1-5 &amp; body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-when.3D1-4"><h3>when=1-4</h3><h4 class="type">macro</h4><div class="usage"><code>(when=1-4 &amp; body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-when.3E.3D1-5"><h3>when&gt;=1-5</h3><h4 class="type">macro</h4><div class="usage"><code>(when&gt;=1-5 &amp; body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-when.3E.3D1-6"><h3>when&gt;=1-6</h3><h4 class="type">macro</h4><div class="usage"><code>(when&gt;=1-6 &amp; body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-without-namespace"><h3>without-namespace</h3><div class="usage"><code>(without-namespace sym)</code></div><div class="doc"><div class="markdown"><p>Return a symbol with the same name as <code>sym</code> but no namespace.</p>
<pre><code> (symbol/without-namespace &#39;clojure.core/even?) =&gt; &#39;even?
</code></pre></div></div></div><div class="public anchor" id="var-without-nils"><h3>without-nils</h3><div class="usage"><code>(without-nils coll)</code></div><div class="doc"><div class="markdown"><p>A lazy sequence of non-nil values of <code>coll</code>.</p></div></div></div></div></body></html>